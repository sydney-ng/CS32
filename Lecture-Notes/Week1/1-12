//Student.h

#ifndef STUDENT_INCLUDED
#define STUDENT_INCLUDED

//#include Course.h

class Course;  			//incomplete type decoration 
class Student
{…
	void enroll (Course* cp); 
…
	Course* m_studyList[10]; 
}; 

#endif //STUDENT_INCLUDED

===================================
//Course.h

#ifndef COURSE_INCLUDED
#define COURSE_INCLUDED
// #include Student.h -> you can do this because Student is only used to create pointers of type Student

class Student; 

class Course
{
	int units() const; 
	Student* m_roster[1000]; 
}; 

#endif //COURSE_INCLUDED

===================================
//myapp.cpp 

#include Student.h
int main()
{
	Student s(…); 
	Course* cp = new course(); 
	s.enroll (cp); 
} 

void Student:: enroll (Course* cp) 
{
	int units = cp->units(); 
} 
===================================
RULES ABOUT C++
- Circular Dependency 
	- Student depends on Course and visa versa
	- now with the class Course; we don’t need to know every detail 
- If you declare a variable or data member of type Foo, the compiler must know how big a Foo object is  
 	- It needs to look through the class to check how big each of the things are 
- If you call a member function of Foo, the compiler must have seen a definition of the Foo class. 
	- Pointers to objects are the same size 
- If you declare a Foo pointer or a Foo reference, all the compiler needs to know is that Foo is the name of a type
- you can have as many incomplete type declarations as long s they’re defined 

===================================

class A
{
	int m_i;
	B m_b; 
} 

Class B
{ 	A m_a; 
	
}

size of A = 4 + size of B
size of B = size of A 

===================================
