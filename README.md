# UCLA's Computer Science 32 - Algorithms and Data Structures

### Professor: David Smallberg
### Quarter: Spring 2018

What is covered below is the fundamental data structures and their use in programming. This includes both class design and features of the C++ programming language.
Projects and Homeworks are built around the design and use of the C++ standard library (STL). By using the standard library, we can show master in the ability to 
write reasonably sophisticated programs quickly.

## Skills Demonstrated 
1) Demonstrate strong problem solving skills in constructing complete C++ programs to tackle exercises inspired by real-world problems.
2) Analyze the performance of algorithms and data structures.
3) Select and use the most appropriate data structure from the C++ standard library (STL) for a particular programming task.
4) Design and implement efficient customized data structures.


# Projects
Description of the following homeworks:

## Project 1:
In this project, we work with constructors, which are special member fucntions that initialize instances of a class. Destructors do the opposite and will de-initialize  an instance of a class. It takes no parameters. Dynamic memory usage is used to allocate memory as needed. Operators `new` and `delete` are used to manage this memory. Assignment operators, copy constructors, and default constructors are examined in this project. 


## Project 2:
In this project, we examine how linked lists work by creating, interfacing with, and deleting linked lists. We use nodes to keep track of the head of the linked list, determine the 
values stored in each node, and iterate until we reach the end of the linked lists. We also examine maps and upsert values to it (depending on the change in the value). 

## **Project 3:**  _Featured Project_
This project examines how class inheritance relationship exists between a superclass and a subclass such that the subclass inherits data structures as well as operation definitions from the superclass without the need to define them again. We will create a hierarchal structure that prevents cyclic dependencies. 
This project is the largest project of the quarter and examines how inheritance, polymorphism, subclasses, and base classes are used in object oriented programming. Each character in the created game is derived from a base class object. We will write both private and public functions to implement the interface for each subclass. This shows how objects can take on many different forms (as when a parent class is referenced by a child class object). 

## Project 4:
In this project, we learn about security and how hashes (algorithms that aim to produce a unique, fixed-length string), tokenizers (which convert input text to streams of tokens, where each token is a separate word, punctuation sign, 
number/amount, date, e-mail, URL/URI, etc.), and decryption (the conversion of encrypted data into its original form) can be implemented using C++. 

# Homeworks 
Description of the following homeworks: 

## Homework 1: 

In this homework, we will demonstrate the difference between deep and shallow copy of objects.
Are able to initialze, create, and delete objects using constructors and deconstructors. We use both public and private functions & variables to demonstrate the 
different aspects of objects. 

## Homework 2: 

In this homework, we will analyze the difference between stacks and queues to solve a maze. Using a queue, selections are processed using FIFO (first in first out), while 
stack selection is done using LRU (Last Recently Used) to find a solution.  

## Homework 3:

We look at tree structures and examine how they are built and processed. We then will see how inheritance can be used for objects to reduce duplication of code, overwrriting over parent functions, and how construction & deconstruction work for these types of classes. 

## Homework 4: 

We examine function overloading as a way to reduce code duplication, look at the the manner in which operators are used, and trace how function complexity depeding on the type of data structures that we choose (and how complexity increases as functions get more and more copmlex). 
